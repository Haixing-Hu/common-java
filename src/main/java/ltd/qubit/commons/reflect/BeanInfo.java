////////////////////////////////////////////////////////////////////////////////
//
//    Copyright (c) 2017 - 2022.
//    Nanjing Smart Medical Investment Operation Service Co. Ltd.
//
//    All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////
package ltd.qubit.commons.reflect;

import ltd.qubit.commons.lang.Equality;
import ltd.qubit.commons.lang.Hash;
import ltd.qubit.commons.reflect.impl.GetterMethod;
import ltd.qubit.commons.text.tostring.ToStringBuilder;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import javax.annotation.Nullable;

import static ltd.qubit.commons.reflect.MethodUtils.getAllMethods;
import static ltd.qubit.commons.reflect.PropertyUtils.getPropertyNameFromGetter;

/**
 * Stores the information about a bean.
 *
 * @author Haixing Hu
 */
public class BeanInfo {

  public static final String DEFAULT_ID_PROPERTY_NAME = "id";

  private static final ClassValue<BeanInfo> CACHE = new ClassValue<BeanInfo>() {
    @Override
    protected BeanInfo computeValue(final Class<?> type) {
      return new BeanInfo(type);
    }
  };

  /**
   * Factory methods for creating a {@link BeanInfo}.
   *
   * @param type
   *     the type of the beans.
   * @return the object storing the information of the beans.
   */
  public static BeanInfo of(final Class<?> type) {
    return CACHE.get(type);
  }

  private final Class<?> type;
  private final List<Property> properties;
  private final Map<String, Property> propertyMap;
  private final Property idProperty;

  private BeanInfo(final Class<?> type) {
    this.type = type;
    this.properties = new ArrayList<>();
    this.propertyMap = new HashMap<>();
    final List<Method> methods = getAllMethods(type, Option.BEAN_METHOD);
    Property id = null;
    for (final Method method : methods) {
      final String propertyName = getPropertyNameFromGetter(method);
      if (propertyName == null) {
        continue;
      }
      final Property property = Property.of(type, propertyName);
      properties.add(property);
      propertyMap.put(propertyName, property);
      if (property.isIdentifier()) {
        id = property;
      }
    }
    this.idProperty = id;
  }

  public String getName() {
    return type.getSimpleName();
  }

  public Class<?> getType() {
    return type;
  }

  public boolean hasProperty(final String name) {
    return propertyMap.containsKey(name);
  }

  public List<Property> getProperties() {
    return new ArrayList<>(properties);
  }

  public List<Property> getProperties(final String... names) {
    final List<Property> result = new ArrayList<>();
    for (final String name : names) {
      if (propertyMap.containsKey(name)) {
        result.add(propertyMap.get(name));
      }
    }
    return result;
  }

  public List<Property> getProperties(final Predicate<Property> cond) {
    final List<Property> result = new ArrayList<>();
    for (final Property prop : properties) {
      if (cond.test(prop)) {
        result.add(prop);
      }
    }
    return result;
  }

  @Nullable
  public Property getProperty(final String name) {
    return propertyMap.get(name);
  }

  @Nullable
  public <T, R> Property getProperty(final GetterMethod<T, R> getter) {
    @SuppressWarnings(
        "unchecked") final String fieldName = FieldUtils.getFieldName(
        (Class<T>) type, getter);
    if (fieldName == null) {
      return null;
    } else {
      return propertyMap.get(fieldName);
    }
  }

  public List<Property> getReferenceProperties() {
    return properties.stream()
                     .filter(Property::isReference)
                     .collect(Collectors.toList());
  }

  public List<Property> getNonComputedProperties() {
    return properties.stream()
                     .filter(Property::isNonComputed)
                     .collect(Collectors.toList());
  }

  @Nullable
  public Property getIdProperty() {
    return idProperty;
  }

  public boolean hasIdProperty() {
    return idProperty != null;
  }

  public boolean hasAutoGeneratedIdProperty() {
    return (idProperty != null) && idProperty.isAutoGeneratedId();
  }

  public List<Property> getRespectToProperties(final Property uniqueProperty) {
    final String[] respectTo = uniqueProperty.getUniqueRespectTo();
    final List<Property> result = new ArrayList<>();
    if (respectTo != null) {
      for (final String name : respectTo) {
        final Property prop = propertyMap.get(name);
        if (prop == null) {
          throw new IllegalStateException("The name in the respect to property "
              + "of the @Unique annotation must be a property of the model: "
              + name);
        }
        result.add(prop);
      }
    }
    result.add(uniqueProperty);
    return result;
  }

  public Object getId(final Object model) {
    if (idProperty == null) {
      throw new IllegalArgumentException(
          "No ID property found for the model: " + this.getName());
    }
    return idProperty.getValue(model);
  }

  public void setId(final Object model, @Nullable final Object value) {
    if (idProperty == null) {
      throw new IllegalArgumentException(
          "No ID property found for the model: " + this.getName());
    }
    idProperty.setValue(model, value);
  }

  public Object get(final Object model, final String propertyName) {
    final Property property = this.getProperty(propertyName);
    if (property == null) {
      throw new IllegalArgumentException("Cannot find property '"
          + propertyName
          + "' for the model "
          + this.getName());
    }
    return property.getValue(model);
  }

  public Object get(final Object model, final Property property) {
    if (property.getOwnerClass() != type) {
      throw new IllegalArgumentException("The owner class of the property "
          + "should be the same as the class of the specified bean.");
    }
    return property.getValue(model);
  }

  public void set(final Object model, final String propertyName,
      final Object propertyValue) {
    final Property property = this.getProperty(propertyName);
    if (property == null) {
      throw new IllegalArgumentException("Cannot find property '"
          + propertyName
          + "' for the model "
          + this.getName());
    }
    property.setValue(model, propertyValue);
  }

  public void set(final Object model, final Property property,
      final Object propertyValue) {
    if (property.getOwnerClass() != type) {
      throw new IllegalArgumentException("The owner class of the property "
          + "should be the same as the class of the specified bean.");
    }
    property.setValue(model, propertyValue);
  }

  public boolean equals(@Nullable final Object o) {
    if (this == o) {
      return true;
    }
    if ((o == null) || (getClass() != o.getClass())) {
      return false;
    }
    final BeanInfo other = (BeanInfo) o;
    return Equality.equals(type, other.type)
        && Equality.equals(properties, other.properties)
        && Equality.equals(propertyMap, other.propertyMap)
        && Equality.equals(idProperty, other.idProperty);
  }

  public int hashCode() {
    final int multiplier = 7;
    int result = 3;
    result = Hash.combine(result, multiplier, type);
    result = Hash.combine(result, multiplier, properties);
    result = Hash.combine(result, multiplier, propertyMap);
    result = Hash.combine(result, multiplier, idProperty);
    return result;
  }

  public String toString() {
    return new ToStringBuilder(this).append("type", type)
                                    .append("properties", properties)
                                    .append("propertyMap", propertyMap)
                                    .append("idProperty", idProperty)
                                    .toString();
  }
}
