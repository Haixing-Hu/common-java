////////////////////////////////////////////////////////////////////////////////
//
//    Copyright (c) 2022 - 2025.
//    Haixing Hu, Qubit Co. Ltd.
//
//    All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////
package ltd.qubit.commons.sql;

import java.io.Serial;
import java.io.Serializable;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;

import javax.annotation.Nullable;

import ltd.qubit.commons.lang.Equality;
import ltd.qubit.commons.lang.Hash;
import ltd.qubit.commons.text.tostring.ToStringBuilder;

/**
 * 此类存储列的元数据。
 *
 * @author 胡海星
 */
public final class ColumnInfo implements Serializable {

  @Serial
  private static final long serialVersionUID = - 6309690229495461909L;

  /**
   * 表示列是有符号的标志。
   */
  public static final int SIGNED = 0x0001;

  /**
   * 表示列是可搜索的标志。
   */
  public static final int SEARCHABLE = 0x0002;

  /**
   * 表示列是自增的标志。
   */
  public static final int AUTO_INCREMENT = 0x0004;

  /**
   * 表示列是大小写敏感的标志。
   */
  public static final int CASE_SENSITIVE = 0x0008;

  /**
   * 表示列是货币类型的标志。
   */
  public static final int CURRENCY = 0x0010;

  /**
   * 表示列不可为空的标志。
   */
  public static final int NON_NULLABLE = 0x0020;

  /**
   * 表示列可为空的标志。
   */
  public static final int NULLABLE = 0x0040;

  /**
   * 表示列是可写的标志。
   */
  public static final int WRITABLE = 0x0080;

  /**
   * 表示列绝对可写的标志。
   */
  public static final int DEFINITELY_WRITABLE = 0x0100 | WRITABLE;

  /**
   * 表示列是自动生成的标志。
   */
  public static final int AUTO_GENERATED = 0x0200;

  /**
   * 空值性标志的组合。
   */
  public static final int NULLABILITY = NON_NULLABLE | NULLABLE;

  /**
   * 可写性标志的组合。
   */
  public static final int WRITABILITY = WRITABLE | DEFINITELY_WRITABLE;

  /**
   * 默认选项标志的组合。
   */
  public static final int DEFAULT_OPTIONS = SIGNED
                                          | SEARCHABLE
                                          | CASE_SENSITIVE;
  /**
   * 列的名称。
   */
  private String name;

  /**
   * 包含该列的表的名称。
   */
  private String table;

  /**
   * 包含该表的目录的名称。
   * <p>
   * 如果目录不可用，则此字段为{@code null}。
   */
  @Nullable
  private String catalog;

  /**
   * 包含该表的模式的名称。
   * <p>
   * 如果模式不可用，则此字段为{@code null}。
   */
  @Nullable
  private String schema;

  /**
   * 数据源相关的列类型名称，对于UDT类型是全限定名称。
   */
  @Nullable
  private String typeName;

  /**
   * 列的SQL类型，来自java.sql.Types。
   */
  private int type;

  /**
   * 列的大小。
   */
  private int size;

  /**
   * 小数位数。
   * <p>
   * 如果小数位数不适用，则此字段为{@code null}。
   */
  @Nullable
  private Integer digits;

  /**
   * 描述列的备注，可能为{@code null}。
   */
  @Nullable
  private String remarks;

  /**
   * 此列的组合选项。
   */
  private int options;

  /**
   * 构造一个新的{@code ColumnInfo}对象。
   */
  public ColumnInfo() {}

  /**
   * 从ResultSet构造ColumnInfo对象。
   *
   * @param rs
   *     包含列元数据的ResultSet。
   * @throws SQLException
   *     如果访问ResultSet时发生SQL错误。
   */
  public ColumnInfo(final ResultSet rs) throws SQLException {
    name = rs.getString("COLUMN_NAME");
    table = rs.getString("TABLE_NAME");
    catalog = rs.getString("TABLE_CAT");
    schema = rs.getString("TABLE_SCHEM");
    typeName = rs.getString("TYPE_NAME");
    type = rs.getInt("DATA_TYPE");
    size = rs.getInt("COLUMN_SIZE");
    digits = rs.getInt("DECIMAL_DIGITS");
    remarks = rs.getString("REMARKS");
    options = 0;
    setNullable(rs.getInt("NULLABLE"));
    setAutoIncrement(rs.getString("IS_AUTOINCREMENT"));
    setAutoGenerated(rs.getString("IS_GENERATEDCOLUMN"));
  }

  /**
   * 获取列的名称。
   *
   * @return 列的名称。
   */
  public String getName() {
    return name;
  }

  /**
   * 设置列的名称。
   *
   * @param name
   *     新的列名称。
   */
  public void setName(final String name) {
    this.name = name;
  }

  /**
   * 获取包含该列的表的名称。
   *
   * @return 表的名称。
   */
  public String getTable() {
    return table;
  }

  /**
   * 设置包含该列的表的名称。
   *
   * @param table
   *     新的表名称。
   */
  public void setTable(final String table) {
    this.table = table;
  }

  /**
   * 获取包含该表的目录的名称。
   *
   * @return 目录的名称，如果目录不可用则为{@code null}。
   */
  @Nullable
  public String getCatalog() {
    return catalog;
  }

  /**
   * 设置包含该表的目录的名称。
   *
   * @param catalog
   *     新的目录名称，可以为{@code null}。
   */
  public void setCatalog(@Nullable final String catalog) {
    this.catalog = catalog;
  }

  /**
   * 获取包含该表的模式的名称。
   *
   * @return 模式的名称，如果模式不可用则为{@code null}。
   */
  @Nullable
  public String getSchema() {
    return schema;
  }

  /**
   * 设置包含该表的模式的名称。
   *
   * @param schema
   *     新的模式名称，可以为{@code null}。
   */
  public void setSchema(@Nullable final String schema) {
    this.schema = schema;
  }

  /**
   * 获取数据源相关的列类型名称。
   *
   * @return 类型名称，对于UDT类型是完全限定名称，可能为{@code null}。
   */
  @Nullable
  public String getTypeName() {
    return typeName;
  }

  /**
   * 设置数据源相关的列类型名称。
   *
   * @param typeName
   *     新的类型名称，可以为{@code null}。
   */
  public void setTypeName(@Nullable final String typeName) {
    this.typeName = typeName;
  }

  /**
   * 获取列的SQL类型。
   *
   * @return 来自java.sql.Types的SQL类型。
   */
  public int getType() {
    return type;
  }

  /**
   * 设置列的SQL类型。
   *
   * @param type
   *     新的SQL类型。
   */
  public void setType(final int type) {
    this.type = type;
  }

  /**
   * 获取列的大小。
   *
   * @return 列的大小。
   */
  public int getSize() {
    return size;
  }

  /**
   * 设置列的大小。
   *
   * @param size
   *     新的列大小。
   */
  public void setSize(final int size) {
    this.size = size;
  }

  /**
   * 获取小数位数。
   *
   * @return 小数位数，如果不适用则为{@code null}。
   */
  @Nullable
  public Integer getDigits() {
    return digits;
  }

  /**
   * 设置小数位数。
   *
   * @param digits
   *     新的小数位数，如果不适用可以为{@code null}。
   */
  public void setDigits(@Nullable final Integer digits) {
    this.digits = digits;
  }

  /**
   * 获取描述列的备注。
   *
   * @return 列的备注，可能为{@code null}。
   */
  @Nullable
  public String getRemarks() {
    return remarks;
  }

  /**
   * 设置描述列的备注。
   *
   * @param remarks
   *     新的备注，可以为{@code null}。
   */
  public void setRemarks(@Nullable final String remarks) {
    this.remarks = remarks;
  }

  /**
   * 获取此列的组合选项。
   *
   * @return 组合选项的值。
   */
  public int getOptions() {
    return options;
  }

  /**
   * 设置此列的组合选项。
   *
   * @param options
   *     新的组合选项值。
   */
  public void setOptions(final int options) {
    this.options = options;
  }

  /**
   * 判断列是否为有符号数。
   *
   * @return 如果列是有符号数则返回{@code true}。
   */
  public boolean isSigned() {
    return (options & SIGNED) != 0;
  }

  /**
   * 设置列是否为有符号数。
   *
   * @param signed
   *     如果为{@code true}则设置为有符号数。
   */
  public void setSigned(final boolean signed) {
    if (signed) {
      options |= SIGNED;
    } else {
      options &= (~ SIGNED);
    }
  }

  /**
   * 判断列是否可搜索。
   *
   * @return 如果列可搜索则返回{@code true}。
   */
  public boolean isSearchable() {
    return (options & SEARCHABLE) != 0;
  }

  /**
   * 设置列是否可搜索。
   *
   * @param searchable
   *     如果为{@code true}则设置为可搜索。
   */
  public void setSearchable(final boolean searchable) {
    if (searchable) {
      options |= SEARCHABLE;
    } else {
      options &= (~ SEARCHABLE);
    }
  }

  /**
   * 判断列是否为自增列。
   *
   * @return 如果列是自增列则返回{@code true}。
   */
  public boolean isAutoIncrement() {
    return (options & AUTO_INCREMENT) != 0;
  }

  /**
   * 根据字符串值设置列是否为自增列。
   *
   * @param autoIncrement
   *     自增标志字符串，"YES"表示自增，"NO"表示非自增，可以为{@code null}。
   */
  public void setAutoIncrement(@Nullable final String autoIncrement) {
    if (autoIncrement != null) {
      switch (autoIncrement) {
        case "YES":
          options |= AUTO_INCREMENT;
          break;
        case "NO":
          options &= (~AUTO_INCREMENT);
          break;
      }
    }
  }

  /**
   * 判断列是否为自动生成列。
   *
   * @return 如果列是自动生成列则返回{@code true}。
   */
  public boolean isAutoGenerated() {
    return (options & AUTO_GENERATED) != 0;
  }

  /**
   * 根据字符串值设置列是否为自动生成列。
   *
   * @param autoGenerated
   *     自动生成标志字符串，"YES"表示自动生成，"NO"表示非自动生成，可以为{@code null}。
   */
  public void setAutoGenerated(final String autoGenerated) {
    if (autoGenerated != null) {
      switch (autoGenerated) {
        case "YES":
          options |= AUTO_GENERATED;
          break;
        case "NO":
          options &= (~AUTO_GENERATED);
          break;
      }
    }
  }

  /**
   * 判断列是否大小写敏感。
   *
   * @return 如果列大小写敏感则返回{@code true}。
   */
  public boolean isCaseSensitive() {
    return (options & CASE_SENSITIVE) != 0;
  }

  /**
   * 设置列是否大小写敏感。
   *
   * @param caseSensitive
   *     如果为{@code true}则设置为大小写敏感。
   */
  public void setCaseSensitive(final boolean caseSensitive) {
    if (caseSensitive) {
      options |= CASE_SENSITIVE;
    } else {
      options &= (~ CASE_SENSITIVE);
    }
  }

  /**
   * 判断列是否为货币类型。
   *
   * @return 如果列是货币类型则返回{@code true}。
   */
  public boolean isCurrency() {
    return (options & CURRENCY) != 0;
  }

  /**
   * 设置列是否为货币类型。
   *
   * @param currency
   *     如果为{@code true}则设置为货币类型。
   */
  public void setCurrency(final boolean currency) {
    if (currency) {
      options |= CURRENCY;
    } else {
      options &= (~ CURRENCY);
    }
  }

  /**
   * 获取列的空值特性。
   *
   * @return {@link ResultSetMetaData#columnNoNulls}表示不可为空，
   *         {@link ResultSetMetaData#columnNullable}表示可为空，
   *         {@link ResultSetMetaData#columnNullableUnknown}表示未知。
   */
  public int isNullable() {
    switch (options & NULLABILITY) {
      case NON_NULLABLE:
        return ResultSetMetaData.columnNoNulls;
      case NULLABLE:
        return ResultSetMetaData.columnNullable;
      default:
        return ResultSetMetaData.columnNullableUnknown;
    }
  }

  /**
   * 设置列的空值特性。
   *
   * @param nullable
   *     空值特性值，可以是{@link ResultSetMetaData#columnNoNulls}、
   *     {@link ResultSetMetaData#columnNullable}或{@link ResultSetMetaData#columnNullableUnknown}。
   */
  public void setNullable(final int nullable) {
    options &= (~ NULLABILITY);
    switch (nullable) {
      case ResultSetMetaData.columnNoNulls:
        options |= NON_NULLABLE;
        break;
      case ResultSetMetaData.columnNullable:
        options |= NULLABLE;
        break;
      case ResultSetMetaData.columnNullableUnknown:
      default:
        break;
    }
  }

  /**
   * 判断列是否为只读。
   *
   * @return 如果列是只读则返回{@code true}。
   */
  public boolean isReadOnly() {
    return (options & WRITABILITY) == 0;
  }

  /**
   * 设置列是否为只读。
   *
   * @param readOnly
   *     如果为{@code true}则设置为只读。
   */
  public void setReadOnly(final boolean readOnly) {
    if (readOnly) {
      options &= (~ WRITABILITY);
    } else {
      options |= WRITABLE;
    }
  }

  /**
   * 判断列是否可写。
   *
   * @return 如果列可写则返回{@code true}。
   */
  public boolean isWritable() {
    return (options & WRITABLE) != 0;
  }

  /**
   * 设置列是否可写。
   *
   * @param writable
   *     如果为{@code true}则设置为可写。
   */
  public void setWritable(final boolean writable) {
    options &= (~ WRITABILITY);
    if (writable) {
      options |= WRITABLE;
    }
  }

  /**
   * 判断列是否绝对可写。
   *
   * @return 如果列绝对可写则返回{@code true}。
   */
  public boolean isDefinitelyWritable() {
    return (options & DEFINITELY_WRITABLE) != 0;
  }

  /**
   * 设置列是否绝对可写。
   *
   * @param definitely
   *     如果为{@code true}则设置为绝对可写。
   */
  public void setDefinitelyWritable(final boolean definitely) {
    options &= (~ WRITABILITY);
    if (definitely) {
      options |= DEFINITELY_WRITABLE;
    }
  }

  @Override
  public boolean equals(final Object o) {
    if (this == o) {
      return true;
    }
    if ((o == null) || (getClass() != o.getClass())) {
      return false;
    }
    final ColumnInfo other = (ColumnInfo) o;
    return Equality.equals(name, other.name)
        && Equality.equals(table, other.table)
        && Equality.equals(catalog, other.catalog)
        && Equality.equals(schema, other.schema)
        && Equality.equals(typeName, other.typeName)
        && Equality.equals(type, other.type)
        && Equality.equals(size, other.size)
        && Equality.equals(digits, other.digits)
        && Equality.equals(remarks, other.remarks)
        && Equality.equals(options, other.options);
  }

  @Override
  public int hashCode() {
    final int multiplier = 7;
    int result = 3;
    result = Hash.combine(result, multiplier, name);
    result = Hash.combine(result, multiplier, table);
    result = Hash.combine(result, multiplier, catalog);
    result = Hash.combine(result, multiplier, schema);
    result = Hash.combine(result, multiplier, typeName);
    result = Hash.combine(result, multiplier, type);
    result = Hash.combine(result, multiplier, size);
    result = Hash.combine(result, multiplier, digits);
    result = Hash.combine(result, multiplier, remarks);
    result = Hash.combine(result, multiplier, options);
    return result;
  }

  @Override
  public String toString() {
    return new ToStringBuilder(this)
        .append("name", name)
        .append("table", table)
        .append("catalog", catalog)
        .append("schema", schema)
        .append("typeName", typeName)
        .append("type", type)
        .append("size", size)
        .append("digits", digits)
        .append("remarks", remarks)
        .append("options", options)
        .toString();
  }
}