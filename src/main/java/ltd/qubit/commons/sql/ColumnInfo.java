////////////////////////////////////////////////////////////////////////////////
//
//    Copyright (c) 2022 - 2025.
//    Haixing Hu, Qubit Co. Ltd.
//
//    All rights reserved.
//
////////////////////////////////////////////////////////////////////////////////
package ltd.qubit.commons.sql;

import java.io.Serial;
import java.io.Serializable;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;

import javax.annotation.Nullable;

import ltd.qubit.commons.lang.Equality;
import ltd.qubit.commons.lang.Hash;
import ltd.qubit.commons.text.tostring.ToStringBuilder;

/**
 * This class stores the metadata of columns.
 *
 * @author Haixing Hu
 */
public final class ColumnInfo implements Serializable {

  @Serial
  private static final long serialVersionUID = - 6309690229495461909L;

  public static final int SIGNED = 0x0001;

  public static final int SEARCHABLE = 0x0002;

  public static final int AUTO_INCREMENT = 0x0004;

  public static final int CASE_SENSITIVE = 0x0008;

  public static final int CURRENCY = 0x0010;

  public static final int NON_NULLABLE = 0x0020;

  public static final int NULLABLE = 0x0040;

  public static final int WRITABLE = 0x0080;

  public static final int DEFINITELY_WRITABLE = 0x0100 | WRITABLE;

  public static final int AUTO_GENERATED = 0x0200;

  public static final int NULLABILITY = NON_NULLABLE | NULLABLE;

  public static final int WRITABILITY = WRITABLE | DEFINITELY_WRITABLE;

  public static final int DEFAULT_OPTIONS = SIGNED
                                          | SEARCHABLE
                                          | CASE_SENSITIVE;
  /**
   * The name of the column.
   */
  private String name;

  /**
   * The name of the table which contains the column.
   */
  private String table;

  /**
   * The name of the catalog which contains the table containing the column.
   * <p>
   * If the catalog is not available, this field is {@code null}.
   */
  @Nullable
  private String catalog;

  /**
   * The name of the schema which contains the table containing the column.
   * <p>
   * If the schema is not available, this field is {@code null}.
   */
  @Nullable
  private String schema;

  /**
   * Data source dependent type name of the column, for a UDT the type name is fully qualified.
   */
  @Nullable
  private String typeName;

  /**
   * The SQL type of the column from java.sql.Types.
   */
  private int type;

  /**
   * The column size.
   */
  private int size;

  /**
   * The number of fractional digits.
   * <p>
   * If the fractional digits is not applicable, this field is {@code null}.
   */
  @Nullable
  private Integer digits;

  /**
   * The comment describing column, which may be {@code null}.
   */
  @Nullable
  private String remarks;

  /**
   * The combined options of this column.
   */
  private int options;

  public ColumnInfo() {}

  public ColumnInfo(final ResultSet rs) throws SQLException {
    name = rs.getString("COLUMN_NAME");
    table = rs.getString("TABLE_NAME");
    catalog = rs.getString("TABLE_CAT");
    schema = rs.getString("TABLE_SCHEM");
    typeName = rs.getString("TYPE_NAME");
    type = rs.getInt("DATA_TYPE");
    size = rs.getInt("COLUMN_SIZE");
    digits = rs.getInt("DECIMAL_DIGITS");
    remarks = rs.getString("REMARKS");
    options = 0;
    setNullable(rs.getInt("NULLABLE"));
    setAutoIncrement(rs.getString("IS_AUTOINCREMENT"));
    setAutoGenerated(rs.getString("IS_GENERATEDCOLUMN"));
  }

  public String getName() {
    return name;
  }

  public void setName(final String name) {
    this.name = name;
  }

  public String getTable() {
    return table;
  }

  public void setTable(final String table) {
    this.table = table;
  }

  @Nullable
  public String getCatalog() {
    return catalog;
  }

  public void setCatalog(@Nullable final String catalog) {
    this.catalog = catalog;
  }

  @Nullable
  public String getSchema() {
    return schema;
  }

  public void setSchema(@Nullable final String schema) {
    this.schema = schema;
  }

  @Nullable
  public String getTypeName() {
    return typeName;
  }

  public void setTypeName(@Nullable final String typeName) {
    this.typeName = typeName;
  }

  public int getType() {
    return type;
  }

  public void setType(final int type) {
    this.type = type;
  }

  public int getSize() {
    return size;
  }

  public void setSize(final int size) {
    this.size = size;
  }

  @Nullable
  public Integer getDigits() {
    return digits;
  }

  public void setDigits(@Nullable final Integer digits) {
    this.digits = digits;
  }

  @Nullable
  public String getRemarks() {
    return remarks;
  }

  public void setRemarks(@Nullable final String remarks) {
    this.remarks = remarks;
  }

  public int getOptions() {
    return options;
  }

  public void setOptions(final int options) {
    this.options = options;
  }

  public boolean isSigned() {
    return (options & SIGNED) != 0;
  }

  public void setSigned(final boolean signed) {
    if (signed) {
      options |= SIGNED;
    } else {
      options &= (~ SIGNED);
    }
  }

  public boolean isSearchable() {
    return (options & SEARCHABLE) != 0;
  }

  public void setSearchable(final boolean searchable) {
    if (searchable) {
      options |= SEARCHABLE;
    } else {
      options &= (~ SEARCHABLE);
    }
  }

  public boolean isAutoIncrement() {
    return (options & AUTO_INCREMENT) != 0;
  }

  public void setAutoIncrement(@Nullable final String autoIncrement) {
    if (autoIncrement != null) {
      switch (autoIncrement) {
        case "YES":
          options |= AUTO_INCREMENT;
          break;
        case "NO":
          options &= (~AUTO_INCREMENT);
          break;
      }
    }
  }

  public boolean isAutoGenerated() {
    return (options & AUTO_GENERATED) != 0;
  }

  public void setAutoGenerated(final String autoGenerated) {
    if (autoGenerated != null) {
      switch (autoGenerated) {
        case "YES":
          options |= AUTO_GENERATED;
          break;
        case "NO":
          options &= (~AUTO_GENERATED);
          break;
      }
    }
  }

  public boolean isCaseSensitive() {
    return (options & CASE_SENSITIVE) != 0;
  }

  public void setCaseSensitive(final boolean caseSensitive) {
    if (caseSensitive) {
      options |= CASE_SENSITIVE;
    } else {
      options &= (~ CASE_SENSITIVE);
    }
  }

  public boolean isCurrency() {
    return (options & CURRENCY) != 0;
  }

  public void setCurrency(final boolean currency) {
    if (currency) {
      options |= CURRENCY;
    } else {
      options &= (~ CURRENCY);
    }
  }

  public int isNullable() {
    switch (options & NULLABILITY) {
      case NON_NULLABLE:
        return ResultSetMetaData.columnNoNulls;
      case NULLABLE:
        return ResultSetMetaData.columnNullable;
      default:
        return ResultSetMetaData.columnNullableUnknown;
    }
  }

  public void setNullable(final int nullable) {
    options &= (~ NULLABILITY);
    switch (nullable) {
      case ResultSetMetaData.columnNoNulls:
        options |= NON_NULLABLE;
        break;
      case ResultSetMetaData.columnNullable:
        options |= NULLABLE;
        break;
      case ResultSetMetaData.columnNullableUnknown:
      default:
        break;
    }
  }

  public boolean isReadOnly() {
    return (options & WRITABILITY) == 0;
  }

  public void setReadOnly(final boolean readOnly) {
    if (readOnly) {
      options &= (~ WRITABILITY);
    } else {
      options |= WRITABLE;
    }
  }

  public boolean isWritable() {
    return (options & WRITABLE) != 0;
  }

  public void setWritable(final boolean writable) {
    options &= (~ WRITABILITY);
    if (writable) {
      options |= WRITABLE;
    }
  }

  public boolean isDefinitelyWritable() {
    return (options & DEFINITELY_WRITABLE) != 0;
  }

  public void setDefinitelyWritable(final boolean definitely) {
    options &= (~ WRITABILITY);
    if (definitely) {
      options |= DEFINITELY_WRITABLE;
    }
  }

  @Override
  public boolean equals(final Object o) {
    if (this == o) {
      return true;
    }
    if ((o == null) || (getClass() != o.getClass())) {
      return false;
    }
    final ColumnInfo other = (ColumnInfo) o;
    return Equality.equals(name, other.name)
        && Equality.equals(table, other.table)
        && Equality.equals(catalog, other.catalog)
        && Equality.equals(schema, other.schema)
        && Equality.equals(typeName, other.typeName)
        && Equality.equals(type, other.type)
        && Equality.equals(size, other.size)
        && Equality.equals(digits, other.digits)
        && Equality.equals(remarks, other.remarks)
        && Equality.equals(options, other.options);
  }

  @Override
  public int hashCode() {
    final int multiplier = 7;
    int result = 3;
    result = Hash.combine(result, multiplier, name);
    result = Hash.combine(result, multiplier, table);
    result = Hash.combine(result, multiplier, catalog);
    result = Hash.combine(result, multiplier, schema);
    result = Hash.combine(result, multiplier, typeName);
    result = Hash.combine(result, multiplier, type);
    result = Hash.combine(result, multiplier, size);
    result = Hash.combine(result, multiplier, digits);
    result = Hash.combine(result, multiplier, remarks);
    result = Hash.combine(result, multiplier, options);
    return result;
  }

  @Override
  public String toString() {
    return new ToStringBuilder(this)
        .append("name", name)
        .append("table", table)
        .append("catalog", catalog)
        .append("schema", schema)
        .append("typeName", typeName)
        .append("type", type)
        .append("size", size)
        .append("digits", digits)
        .append("remarks", remarks)
        .append("options", options)
        .toString();
  }
}